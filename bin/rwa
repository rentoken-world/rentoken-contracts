#!/bin/bash

# RWA CLI Tool - Real World Asset management CLI based on Foundry cast
# Version: 1.0.0

set -e

# === å‡½æ•°ç­¾åé…ç½®ï¼ˆå¯é€šè¿‡ç¯å¢ƒå˜é‡è¦†ç›–ï¼‰===
SIG_KYC_CHECK="${SIG_KYC_CHECK:-isWhitelisted(address)(bool)}"
SIG_KYC_ADD="${SIG_KYC_ADD:-addToWhitelist(address)}"
SIG_KYC_REMOVE="${SIG_KYC_REMOVE:-removeFromWhitelist(address)}"
SIG_PROPERTY_ADD="${SIG_PROPERTY_ADD:-addOrUpdateProperty(uint256,(uint256,address,uint256,uint256,uint256,uint64,uint64,address,bytes32,string))}"
SIG_SERIES_CREATE="${SIG_SERIES_CREATE:-createSeries(uint256,string,string)}"
SIG_SERIES_ADDR_BY_ID="${SIG_SERIES_ADDR_BY_ID:-getSeriesAddress(uint256)(address)}"
SIG_SERIES_SET_ORACLES="${SIG_SERIES_SET_ORACLES:-setOraclesForSeries(uint256,address,address)}"
SIG_FACTORY_RECEIVE_PROFIT="${SIG_FACTORY_RECEIVE_PROFIT:-receiveProfit(uint256,uint256)}"

# ERC20 æ ‡å‡†å‡½æ•°ç­¾å
SIG_ERC20_NAME="name()(string)"
SIG_ERC20_SYMBOL="symbol()(string)"
SIG_ERC20_DECIMALS="decimals()(uint8)"
SIG_ERC20_TOTAL_SUPPLY="totalSupply()(uint256)"
SIG_ERC20_BALANCE_OF="balanceOf(address)(uint256)"
SIG_ERC20_TRANSFER="transfer(address,uint256)"
SIG_ERC20_APPROVE="approve(address,uint256)"

# RentToken ç‰¹æ®Šå‡½æ•°ç­¾å
SIG_RENT_GET_PHASE="getPhase()(uint8)"
SIG_RENT_CLAIMABLE="claimable(address)(uint256)"
SIG_RENT_CONTRIBUTE="contribute(uint256)"

# === å…¨å±€å˜é‡ ===
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
FORCE=${FORCE:-0}

# === ä¾èµ–æ£€æŸ¥ ===
check_dependencies() {
    command -v cast >/dev/null 2>&1 || { 
        echo "âŒ Error: 'cast' command not found. Please install Foundry."
        echo "Visit: https://book.getfoundry.sh/getting-started/installation"
        exit 1
    }
    
    command -v jq >/dev/null 2>&1 || { 
        echo "âŒ Error: 'jq' command not found. Please install jq."
        echo "On macOS: brew install jq"
        echo "On Ubuntu: sudo apt-get install jq"
        exit 1
    }
}

# === ç¯å¢ƒåŠ è½½ ===
load_env() {
    local env_file="$PROJECT_ROOT/.env"
    
    if [[ ! -f "$env_file" ]]; then
        echo "âŒ Error: .env file not found at $env_file"
        echo "Please run 'scripts/init-local.sh' first"
        exit 1
    fi
    
    set -a  # è‡ªåŠ¨å¯¼å‡ºå˜é‡
    source "$env_file"
    set +a
    
    # è®¾ç½®é»˜è®¤å€¼
    RPC_URL=${RPC_URL:-http://localhost:8545}
    NETWORK=${NETWORK:-mainnet-fork}
    CHAIN_ID=${CHAIN_ID:-1}
}

# === åœ°å€æ–‡ä»¶ç®¡ç† ===
load_addresses() {
    local addr_file="$PROJECT_ROOT/addresses/${NETWORK}.json"
    
    if [[ ! -f "$addr_file" ]]; then
        echo "âŒ Error: Address file not found: $addr_file"
        echo "Please run 'scripts/init-local.sh' first"
        exit 1
    fi
    
    # è¯»å–åˆçº¦åœ°å€
    KYC_ORACLE_ADDR=$(jq -r '.KYCOracle // ""' "$addr_file")
    PROPERTY_ORACLE_ADDR=$(jq -r '.PropertyOracle // ""' "$addr_file")
    SERIES_FACTORY_ADDR=$(jq -r '.SeriesFactory // ""' "$addr_file")
    RENT_TOKEN_IMPL_ADDR=$(jq -r '.RentTokenImpl // ""' "$addr_file")
    SANCTION_ORACLE_ADDR=$(jq -r '.SanctionOracle // ""' "$addr_file")
}

# === åœ°å€å†™å…¥ ===
save_address() {
    local key="$1"
    local address="$2"
    local addr_file="$PROJECT_ROOT/addresses/${NETWORK}.json"
    
    # ä½¿ç”¨ jq æ›´æ–° JSON æ–‡ä»¶
    local tmp_file=$(mktemp)
    jq --arg key "$key" --arg addr "$address" '.[$key] = $addr' "$addr_file" > "$tmp_file"
    mv "$tmp_file" "$addr_file"
    
    echo "âœ… Address saved: $key = $address"
}

# === é“¾æ ¡éªŒ ===
verify_chain() {
    if [[ -n "$CHAIN_ID" ]]; then
        local current_chain_id
        current_chain_id=$(cast chain-id --rpc-url "$RPC_URL" 2>/dev/null || echo "0")
        
        if [[ "$current_chain_id" != "$CHAIN_ID" ]]; then
            echo "âŒ Error: Chain ID mismatch!"
            echo "Expected: $CHAIN_ID, Got: $current_chain_id"
            echo "Please check your RPC_URL and CHAIN_ID configuration"
            exit 1
        fi
    fi
}

# === åœ°å€è§£æ ===
resolve_address() {
    local addr="$1"
    
    # å¦‚æœå·²ç»æ˜¯åœ°å€æ ¼å¼ï¼Œç›´æ¥è¿”å›
    if [[ "$addr" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
        echo "$addr"
        return
    fi
    
    # å°è¯•ä»ç¯å¢ƒå˜é‡è§£æè§’è‰² (è½¬å¤§å†™)
    addr_upper=$(echo "$addr" | tr '[:lower:]' '[:upper:]')
    case "$addr_upper" in
        "ADMIN")
            echo "${ADMIN_ADDRESS:-$(cast wallet address --private-key "${ADMIN_PRIVATE_KEY}")}"
            ;;
        "USER1")
            echo "${USER1_ADDRESS:-$(cast wallet address --private-key "${USER1_PRIVATE_KEY}")}"
            ;;
        "USER2")
            echo "${USER2_ADDRESS:-$(cast wallet address --private-key "${USER2_PRIVATE_KEY}")}"
            ;;
        "USER3")
            echo "${USER3_ADDRESS:-$(cast wallet address --private-key "${USER3_PRIVATE_KEY}")}"
            ;;
        "USER4")
            echo "${USER4_ADDRESS:-$(cast wallet address --private-key "${USER4_PRIVATE_KEY}")}"
            ;;
        *)
            echo "$addr"  # è¿”å›åŸå€¼
            ;;
    esac
}

# === ç§é’¥è§£æ ===
resolve_private_key() {
    local role="$1"
    
    role_upper=$(echo "$role" | tr '[:lower:]' '[:upper:]')
    case "$role_upper" in
        "ADMIN")
            echo "$ADMIN_PRIVATE_KEY"
            ;;
        "USER1")
            echo "$USER1_PRIVATE_KEY"
            ;;
        "USER2")
            echo "$USER2_PRIVATE_KEY"
            ;;
        "USER3")
            echo "$USER3_PRIVATE_KEY"
            ;;
        "USER4")
            echo "$USER4_PRIVATE_KEY"
            ;;
        *)
            # å¦‚æœæ˜¯åœ°å€æ ¼å¼ï¼Œå°è¯•æ‰¾å¯¹åº”çš„ç§é’¥
            if [[ "$role" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
                local addr=$(resolve_address "ADMIN")
                if [[ "$addr" == "$role" ]]; then
                    echo "$ADMIN_PRIVATE_KEY"
                    return
                fi
                
                addr=$(resolve_address "USER1")
                if [[ "$addr" == "$role" ]]; then
                    echo "$USER1_PRIVATE_KEY"
                    return
                fi
                
                addr=$(resolve_address "USER2")
                if [[ "$addr" == "$role" ]]; then
                    echo "$USER2_PRIVATE_KEY"
                    return
                fi
                
                addr=$(resolve_address "USER3")
                if [[ "$addr" == "$role" ]]; then
                    echo "$USER3_PRIVATE_KEY"
                    return
                fi
                
                addr=$(resolve_address "USER4")
                if [[ "$addr" == "$role" ]]; then
                    echo "$USER4_PRIVATE_KEY"
                    return
                fi
                
                echo "âŒ Error: No private key found for address $role" >&2
                exit 1
            else
                echo "âŒ Error: Unknown role or invalid address: $role" >&2
                exit 1
            fi
            ;;
    esac
}

# === ç³»åˆ—åœ°å€è§£æ ===
resolve_series_address() {
    local input="$1"
    
    # å¦‚æœå·²ç»æ˜¯åœ°å€æ ¼å¼ï¼Œç›´æ¥è¿”å›
    if [[ "$input" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
        echo "$input"
        return
    fi
    
    # å¦åˆ™å½“ä½œ propertyId å¤„ç†
    local series_addr
    series_addr=$(cast call --rpc-url "$RPC_URL" "$SERIES_FACTORY_ADDR" "$SIG_SERIES_ADDR_BY_ID" "$input" 2>/dev/null || echo "0x0000000000000000000000000000000000000000")
    
    if [[ "$series_addr" == "0x0000000000000000000000000000000000000000" ]]; then
        echo "âŒ Error: No series found for property ID $input" >&2
        exit 1
    fi
    
    echo "$series_addr"
}

# === æ‰§è¡Œå‘½ä»¤ï¼ˆæ”¯æŒ dry-runï¼‰===
execute_command() {
    local dry_run="$1"
    shift
    local cmd=("$@")
    
    if [[ "$dry_run" == "true" ]]; then
        echo "ğŸ” Dry run - would execute:"
        echo "${cmd[*]}"
        return 0
    else
        echo "ğŸš€ Executing: ${cmd[*]}"
        "${cmd[@]}"
    fi
}

# === éœ€è¦ç¡®è®¤çš„å†™æ“ä½œ ===
require_confirmation() {
    local dry_run="$1"
    local yes_flag="$2"
    
    if [[ "$dry_run" == "true" ]]; then
        return 0  # dry-run æ¨¡å¼æ— éœ€ç¡®è®¤
    fi
    
    if [[ "$yes_flag" != "true" && "$FORCE" != "1" ]]; then
        echo "âŒ Error: This operation requires confirmation."
        echo "Use --yes flag or set FORCE=1 environment variable"
        exit 1
    fi
}

# === å‘½ä»¤å®ç° ===

# è´¦æˆ·/ç¯å¢ƒå‘½ä»¤
cmd_addr_show() {
    local role="$1"
    
    if [[ -z "$role" ]]; then
        echo "Usage: rwa addr:show <ROLE>"
        echo "Roles: ADMIN, USER1, USER2, USER3, USER4"
        exit 1
    fi
    
    local addr
    addr=$(resolve_address "$role")
    echo "$addr"
}

cmd_block_time() {
    cast block --rpc-url "$RPC_URL" latest --field timestamp
}

cmd_block_chainid() {
    cast chain-id --rpc-url "$RPC_URL"
}

# KYC å‘½ä»¤
cmd_kyc_check() {
    local addr="$1"
    addr=$(resolve_address "$addr")
    
    cast call --rpc-url "$RPC_URL" "$KYC_ORACLE_ADDR" "$SIG_KYC_CHECK" "$addr"
}

cmd_kyc_add() {
    local addr="$1"
    local dry_run="$2"
    local yes_flag="$3"
    
    addr=$(resolve_address "$addr")
    require_confirmation "$dry_run" "$yes_flag"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$ADMIN_PRIVATE_KEY" 
               "$KYC_ORACLE_ADDR" "$SIG_KYC_ADD" "$addr")
    
    execute_command "$dry_run" "${cmd[@]}"
}

cmd_kyc_remove() {
    local addr="$1"
    local dry_run="$2"
    local yes_flag="$3"
    
    addr=$(resolve_address "$addr")
    require_confirmation "$dry_run" "$yes_flag"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$ADMIN_PRIVATE_KEY" 
               "$KYC_ORACLE_ADDR" "$SIG_KYC_REMOVE" "$addr")
    
    execute_command "$dry_run" "${cmd[@]}"
}

# æˆ¿äº§å‘½ä»¤
cmd_property_add() {
    local property_id=""
    local payout=""
    local valuation=""
    local min=""
    local max=""
    local start=""
    local end=""
    local landlord=""
    local doc_hash=""
    local url=""
    local dry_run="false"
    local yes_flag="false"
    
    # è§£æå‚æ•°
    while [[ $# -gt 0 ]]; do
        case $1 in
            --id)
                property_id="$2"
                shift 2
                ;;
            --payout)
                payout="$2"
                shift 2
                ;;
            --valuation)
                valuation="$2"
                shift 2
                ;;
            --min)
                min="$2"
                shift 2
                ;;
            --max)
                max="$2"
                shift 2
                ;;
            --start)
                if [[ "$2" =~ ^\+ ]]; then
                    # ç›¸å¯¹æ—¶é—´ï¼Œå¦‚ +3600
                    local offset="${2#+}"
                    local current_time
                    current_time=$(cast block --rpc-url "$RPC_URL" latest --field timestamp)
                    start=$((current_time + offset))
                else
                    start="$2"
                fi
                shift 2
                ;;
            --end)
                if [[ "$2" =~ ^\+ ]]; then
                    # ç›¸å¯¹æ—¶é—´ï¼Œå¦‚ +157680000
                    local offset="${2#+}"
                    local current_time
                    current_time=$(cast block --rpc-url "$RPC_URL" latest --field timestamp)
                    end=$((current_time + offset))
                else
                    end="$2"
                fi
                shift 2
                ;;
            --landlord)
                landlord="$2"
                shift 2
                ;;
            --doc-hash)
                doc_hash="$2"
                shift 2
                ;;
            --url)
                url="$2"
                shift 2
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            --yes)
                yes_flag="true"
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # éªŒè¯å¿…éœ€å‚æ•°
    if [[ -z "$property_id" || -z "$payout" || -z "$valuation" || -z "$min" || -z "$max" || -z "$start" || -z "$end" || -z "$landlord" || -z "$doc_hash" || -z "$url" ]]; then
        echo "Usage: rwa property:add --id <id> --payout <token> --valuation <amount> --min <amount> --max <amount> --start <timestamp> --end <timestamp> --landlord <addr> --doc-hash <hash> --url <url> [--yes] [--dry-run]"
        exit 1
    fi
    
    # è§£æåœ°å€
    payout=$(resolve_address "$payout")
    landlord=$(resolve_address "$landlord")
    
    require_confirmation "$dry_run" "$yes_flag"
    
    # æ„é€  PropertyData ç»“æ„ä½“
    local property_data="($property_id,$payout,$valuation,$min,$max,$start,$end,$landlord,$doc_hash,\"$url\")"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$ADMIN_PRIVATE_KEY" 
               "$PROPERTY_ORACLE_ADDR" "$SIG_PROPERTY_ADD" "$property_id" "$property_data")
    
    execute_command "$dry_run" "${cmd[@]}"
}

# ç³»åˆ—å‘½ä»¤
cmd_series_create() {
    local property_id="$1"
    local name="$2"
    local symbol="$3"
    local dry_run="false"
    local yes_flag="false"
    
    # è§£æå‰©ä½™å‚æ•°
    shift 3
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                dry_run="true"
                shift
                ;;
            --yes)
                yes_flag="true"
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ -z "$property_id" || -z "$name" || -z "$symbol" ]]; then
        echo "Usage: rwa series:create <propertyId> <name> <symbol> [--yes] [--dry-run]"
        exit 1
    fi
    
    require_confirmation "$dry_run" "$yes_flag"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$ADMIN_PRIVATE_KEY" 
               "$SERIES_FACTORY_ADDR" "$SIG_SERIES_CREATE" "$property_id" "$name" "$symbol")
    
    execute_command "$dry_run" "${cmd[@]}"
}

cmd_series_oracles_set() {
    local property_id="$1"
    local kyc_addr="$2"
    local sanction_addr="$3"
    local dry_run="false"
    local yes_flag="false"
    
    # è§£æå‰©ä½™å‚æ•°
    shift 3
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                dry_run="true"
                shift
                ;;
            --yes)
                yes_flag="true"
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ -z "$property_id" || -z "$kyc_addr" || -z "$sanction_addr" ]]; then
        echo "Usage: rwa series:oracles:set <propertyId> <kycAddr> <sanctionAddr> [--yes] [--dry-run]"
        exit 1
    fi
    
    kyc_addr=$(resolve_address "$kyc_addr")
    sanction_addr=$(resolve_address "$sanction_addr")
    
    require_confirmation "$dry_run" "$yes_flag"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$ADMIN_PRIVATE_KEY" 
               "$SERIES_FACTORY_ADDR" "$SIG_SERIES_SET_ORACLES" "$property_id" "$kyc_addr" "$sanction_addr")
    
    execute_command "$dry_run" "${cmd[@]}"
}

cmd_series_addr() {
    local property_id="$1"
    
    if [[ -z "$property_id" ]]; then
        echo "Usage: rwa series:addr <propertyId>"
        exit 1
    fi
    
    cast call --rpc-url "$RPC_URL" "$SERIES_FACTORY_ADDR" "$SIG_SERIES_ADDR_BY_ID" "$property_id"
}

cmd_series_info() {
    local input="$1"
    
    if [[ -z "$input" ]]; then
        echo "Usage: rwa series:info <seriesAddr|propertyId>"
        exit 1
    fi
    
    local series_addr
    series_addr=$(resolve_series_address "$input")
    
    echo "ğŸ“Š Series Information:"
    echo "Contract Address: $series_addr"
    
    # è·å–åŸºæœ¬ä»£å¸ä¿¡æ¯
    local name symbol decimals total_supply
    name=$(cast call --rpc-url "$RPC_URL" "$series_addr" "$SIG_ERC20_NAME" 2>/dev/null || echo "N/A")
    symbol=$(cast call --rpc-url "$RPC_URL" "$series_addr" "$SIG_ERC20_SYMBOL" 2>/dev/null || echo "N/A")
    decimals=$(cast call --rpc-url "$RPC_URL" "$series_addr" "$SIG_ERC20_DECIMALS" 2>/dev/null || echo "N/A")
    total_supply=$(cast call --rpc-url "$RPC_URL" "$series_addr" "$SIG_ERC20_TOTAL_SUPPLY" 2>/dev/null || echo "N/A")
    
    echo "Name: $name"
    echo "Symbol: $symbol"
    echo "Decimals: $decimals"
    echo "Total Supply: $total_supply"
    
    # è·å–é˜¶æ®µä¿¡æ¯
    local phase
    phase=$(cast call --rpc-url "$RPC_URL" "$series_addr" "$SIG_RENT_GET_PHASE" 2>/dev/null || echo "N/A")
    local phase_name
    case $phase in
        0) phase_name="Fundraising" ;;
        1) phase_name="AccrualStarted" ;;
        2) phase_name="RaisingFailed" ;;
        3) phase_name="AccrualFinished" ;;
        4) phase_name="Terminated" ;;
        *) phase_name="Unknown" ;;
    esac
    
    echo "Phase: $phase ($phase_name)"
}

cmd_series_phase() {
    local input="$1"
    
    if [[ -z "$input" ]]; then
        echo "Usage: rwa series:phase <seriesAddr|propertyId>"
        exit 1
    fi
    
    local series_addr
    series_addr=$(resolve_series_address "$input")
    
    cast call --rpc-url "$RPC_URL" "$series_addr" "$SIG_RENT_GET_PHASE"
}

cmd_series_contribute() {
    local input="$1"
    local amount="$2"
    local from=""
    local dry_run="false"
    local yes_flag="false"
    
    # è§£æå‰©ä½™å‚æ•°
    shift 2
    while [[ $# -gt 0 ]]; do
        case $1 in
            --from)
                from="$2"
                shift 2
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            --yes)
                yes_flag="true"
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ -z "$input" || -z "$amount" ]]; then
        echo "Usage: rwa series:contribute <seriesAddr|propertyId> <amount> [--from <role|addr>] [--yes] [--dry-run]"
        exit 1
    fi
    
    local series_addr
    series_addr=$(resolve_series_address "$input")
    
    # ç¡®å®šè°ƒç”¨è€…
    if [[ -z "$from" ]]; then
        from="ADMIN"  # é»˜è®¤ä½¿ç”¨ ADMIN
    fi
    
    local private_key
    private_key=$(resolve_private_key "$from")
    
    require_confirmation "$dry_run" "$yes_flag"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$private_key" 
               "$series_addr" "$SIG_RENT_CONTRIBUTE" "$amount")
    
    execute_command "$dry_run" "${cmd[@]}"
}

cmd_series_transfer() {
    local input="$1"
    local to="$2"
    local amount="$3"
    local from=""
    local dry_run="false"
    local yes_flag="false"
    
    # è§£æå‰©ä½™å‚æ•°
    shift 3
    while [[ $# -gt 0 ]]; do
        case $1 in
            --from)
                from="$2"
                shift 2
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            --yes)
                yes_flag="true"
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ -z "$input" || -z "$to" || -z "$amount" ]]; then
        echo "Usage: rwa series:transfer <seriesAddr|propertyId> <to> <amount> [--from <role|addr>] [--yes] [--dry-run]"
        exit 1
    fi
    
    local series_addr
    series_addr=$(resolve_series_address "$input")
    
    to=$(resolve_address "$to")
    
    # ç¡®å®šè°ƒç”¨è€…
    if [[ -z "$from" ]]; then
        from="ADMIN"  # é»˜è®¤ä½¿ç”¨ ADMIN
    fi
    
    local private_key
    private_key=$(resolve_private_key "$from")
    
    require_confirmation "$dry_run" "$yes_flag"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$private_key" 
               "$series_addr" "$SIG_ERC20_TRANSFER" "$to" "$amount")
    
    execute_command "$dry_run" "${cmd[@]}"
}

cmd_series_claimable() {
    local input="$1"
    local addr="$2"
    
    if [[ -z "$input" || -z "$addr" ]]; then
        echo "Usage: rwa series:claimable <seriesAddr|propertyId> <addr>"
        exit 1
    fi
    
    local series_addr
    series_addr=$(resolve_series_address "$input")
    
    addr=$(resolve_address "$addr")
    
    cast call --rpc-url "$RPC_URL" "$series_addr" "$SIG_RENT_CLAIMABLE" "$addr"
}

# å·¥å‚æ”¶ç›Šå‘½ä»¤
cmd_factory_profit_receive() {
    local property_id="$1"
    local amount="$2"
    local dry_run="false"
    local yes_flag="false"
    
    # è§£æå‰©ä½™å‚æ•°
    shift 2
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                dry_run="true"
                shift
                ;;
            --yes)
                yes_flag="true"
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ -z "$property_id" || -z "$amount" ]]; then
        echo "Usage: rwa factory:profit:receive <propertyId> <amount> [--yes] [--dry-run]"
        exit 1
    fi
    
    require_confirmation "$dry_run" "$yes_flag"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$ADMIN_PRIVATE_KEY" 
               "$SERIES_FACTORY_ADDR" "$SIG_FACTORY_RECEIVE_PROFIT" "$property_id" "$amount")
    
    execute_command "$dry_run" "${cmd[@]}"
}

# ERC20 é€šç”¨å‘½ä»¤
cmd_erc20_approve() {
    local token="$1"
    local spender="$2"
    local amount="$3"
    local from=""
    local dry_run="false"
    local yes_flag="false"
    
    # è§£æå‰©ä½™å‚æ•°
    shift 3
    while [[ $# -gt 0 ]]; do
        case $1 in
            --from)
                from="$2"
                shift 2
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            --yes)
                yes_flag="true"
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ -z "$token" || -z "$spender" || -z "$amount" ]]; then
        echo "Usage: rwa erc20:approve <token> <spender> <amount> [--from <role|addr>] [--yes] [--dry-run]"
        exit 1
    fi
    
    token=$(resolve_address "$token")
    spender=$(resolve_address "$spender")
    
    # ç¡®å®šè°ƒç”¨è€…
    if [[ -z "$from" ]]; then
        from="ADMIN"  # é»˜è®¤ä½¿ç”¨ ADMIN
    fi
    
    local private_key
    private_key=$(resolve_private_key "$from")
    
    require_confirmation "$dry_run" "$yes_flag"
    
    local cmd=(cast send --rpc-url "$RPC_URL" --private-key "$private_key" 
               "$token" "$SIG_ERC20_APPROVE" "$spender" "$amount")
    
    execute_command "$dry_run" "${cmd[@]}"
}

cmd_erc20_balance() {
    local token="$1"
    local addr="$2"
    
    if [[ -z "$token" || -z "$addr" ]]; then
        echo "Usage: rwa erc20:balance <token> <addr>"
        exit 1
    fi
    
    token=$(resolve_address "$token")
    addr=$(resolve_address "$addr")
    
    cast call --rpc-url "$RPC_URL" "$token" "$SIG_ERC20_BALANCE_OF" "$addr"
}

# æœ¬åœ°æµ‹è¯•è¾…åŠ©å‘½ä»¤
cmd_imp_start() {
    local addr="$1"
    
    if [[ -z "$addr" ]]; then
        echo "Usage: rwa imp:start <addr>"
        exit 1
    fi
    
    addr=$(resolve_address "$addr")
    
    cast rpc --rpc-url "$RPC_URL" anvil_impersonateAccount "$addr"
    echo "âœ… Started impersonating $addr"
}

cmd_imp_stop() {
    local addr="$1"
    
    if [[ -z "$addr" ]]; then
        echo "Usage: rwa imp:stop <addr>"
        exit 1
    fi
    
    addr=$(resolve_address "$addr")
    
    cast rpc --rpc-url "$RPC_URL" anvil_stopImpersonatingAccount "$addr"
    echo "âœ… Stopped impersonating $addr"
}

cmd_time_increase() {
    local seconds="$1"
    
    if [[ -z "$seconds" ]]; then
        echo "Usage: rwa time:increase <seconds>"
        exit 1
    fi
    
    cast rpc --rpc-url "$RPC_URL" evm_increaseTime "$seconds"
    echo "âœ… Time increased by $seconds seconds"
}

cmd_mine() {
    cast rpc --rpc-url "$RPC_URL" evm_mine
    echo "âœ… New block mined"
}

# === å¸®åŠ©ä¿¡æ¯ ===
show_help() {
    cat << EOF
RWA CLI Tool - Real World Asset management CLI

Usage: rwa <command> [options]

è´¦æˆ·/ç¯å¢ƒ:
  addr:show <ROLE>              æ˜¾ç¤ºè§’è‰²åœ°å€
  block:time                    æ˜¾ç¤ºå½“å‰åŒºå—æ—¶é—´
  block:chainid                 æ˜¾ç¤ºå½“å‰é“¾ID

KYC ç®¡ç†:
  kyc:check <addr>              æ£€æŸ¥ KYC çŠ¶æ€
  kyc:add <addr> [--yes] [--dry-run]    æ·»åŠ åˆ° KYC ç™½åå•
  kyc:remove <addr> [--yes] [--dry-run] ä» KYC ç™½åå•ç§»é™¤

æˆ¿äº§ç®¡ç†:
  property:add --id <id> --payout <token> --valuation <amount> 
               --min <amount> --max <amount> --start <timestamp> 
               --end <timestamp> --landlord <addr> --doc-hash <hash> 
               --url <url> [--yes] [--dry-run]
                                æ·»åŠ æˆ–æ›´æ–°æˆ¿äº§

ç³»åˆ—ç®¡ç†:
  series:create <propertyId> <name> <symbol> [--yes] [--dry-run]
                                åˆ›å»º RentToken ç³»åˆ—
  series:oracles:set <propertyId> <kycAddr> <sanctionAddr> [--yes] [--dry-run]
                                è®¾ç½®ç³»åˆ— Oracle
  series:addr <propertyId>      æŸ¥è¯¢ç³»åˆ—åˆçº¦åœ°å€
  series:info <seriesAddr|propertyId>   æ˜¾ç¤ºç³»åˆ—ä¿¡æ¯
  series:phase <seriesAddr|propertyId>  æ˜¾ç¤ºç³»åˆ—é˜¶æ®µ
  series:contribute <seriesAddr|propertyId> <amount> [--from <role|addr>] [--yes] [--dry-run]
                                å‘ç³»åˆ—è´¡çŒ®èµ„é‡‘
  series:transfer <seriesAddr|propertyId> <to> <amount> [--from <role|addr>] [--yes] [--dry-run]
                                è½¬ç§»ç³»åˆ—ä»£å¸
  series:claimable <seriesAddr|propertyId> <addr>   æŸ¥è¯¢å¯æå–æ”¶ç›Š

å·¥å‚æ”¶ç›Š:
  factory:profit:receive <propertyId> <amount> [--yes] [--dry-run]
                                åˆ†å‘æ”¶ç›Š

ERC20 é€šç”¨:
  erc20:approve <token> <spender> <amount> [--from <role|addr>] [--yes] [--dry-run]
                                æˆæƒä»£å¸
  erc20:balance <token> <addr>  æŸ¥è¯¢ä»£å¸ä½™é¢

æœ¬åœ°æµ‹è¯•:
  imp:start <addr>              å¼€å§‹æ¨¡æ‹Ÿåœ°å€
  imp:stop <addr>               åœæ­¢æ¨¡æ‹Ÿåœ°å€
  time:increase <seconds>       å¢åŠ åŒºå—æ—¶é—´
  mine                          æŒ–æ˜æ–°åŒºå—

å…¨å±€é€‰é¡¹:
  --dry-run                     ä»…æ˜¾ç¤ºå°†æ‰§è¡Œçš„å‘½ä»¤ï¼Œä¸å®é™…æ‰§è¡Œ
  --yes                         è·³è¿‡ç¡®è®¤ï¼Œç›´æ¥æ‰§è¡Œå†™æ“ä½œ
  --from <role|addr>            æŒ‡å®šè°ƒç”¨è€…ï¼ˆç”¨äºéœ€è¦ç§é’¥çš„æ“ä½œï¼‰

ç¯å¢ƒå˜é‡:
  FORCE=1                       ç­‰åŒäº --yes
  
è§’è‰²åç§°: ADMIN, USER1, USER2, USER3, USER4

æ›´å¤šä¿¡æ¯è¯·æŸ¥çœ‹: docs/CLI.md
EOF
}

# === ä¸»å‘½ä»¤åˆ†å‘ ===
main() {
    # æ£€æŸ¥ä¾èµ–
    check_dependencies
    
    # å¦‚æœæ²¡æœ‰å‚æ•°ï¼Œæ˜¾ç¤ºå¸®åŠ©
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    # è§£æå‘½ä»¤
    local command="$1"
    shift
    
    # åŠ è½½é…ç½®ï¼ˆé™¤äº†å¸®åŠ©å‘½ä»¤å¤–éƒ½éœ€è¦ï¼‰
    if [[ "$command" != "help" && "$command" != "--help" && "$command" != "-h" ]]; then
        load_env
        load_addresses
        verify_chain
    fi
    
    # åˆ†å‘å‘½ä»¤
    case "$command" in
        # è´¦æˆ·/ç¯å¢ƒ
        "addr:show")
            cmd_addr_show "$@"
            ;;
        "block:time")
            cmd_block_time
            ;;
        "block:chainid")
            cmd_block_chainid
            ;;
        
        # KYC
        "kyc:check")
            cmd_kyc_check "$@"
            ;;
        "kyc:add")
            local addr="$1"
            local dry_run="false"
            local yes_flag="false"
            
            shift
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --dry-run)
                        dry_run="true"
                        shift
                        ;;
                    --yes)
                        yes_flag="true"
                        shift
                        ;;
                    *)
                        echo "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            
            cmd_kyc_add "$addr" "$dry_run" "$yes_flag"
            ;;
        "kyc:remove")
            local addr="$1"
            local dry_run="false"
            local yes_flag="false"
            
            shift
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --dry-run)
                        dry_run="true"
                        shift
                        ;;
                    --yes)
                        yes_flag="true"
                        shift
                        ;;
                    *)
                        echo "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            
            cmd_kyc_remove "$addr" "$dry_run" "$yes_flag"
            ;;
        
        # æˆ¿äº§
        "property:add")
            cmd_property_add "$@"
            ;;
        
        # ç³»åˆ—
        "series:create")
            cmd_series_create "$@"
            ;;
        "series:oracles:set")
            cmd_series_oracles_set "$@"
            ;;
        "series:addr")
            cmd_series_addr "$@"
            ;;
        "series:info")
            cmd_series_info "$@"
            ;;
        "series:phase")
            cmd_series_phase "$@"
            ;;
        "series:contribute")
            cmd_series_contribute "$@"
            ;;
        "series:transfer")
            cmd_series_transfer "$@"
            ;;
        "series:claimable")
            cmd_series_claimable "$@"
            ;;
        
        # å·¥å‚æ”¶ç›Š
        "factory:profit:receive")
            cmd_factory_profit_receive "$@"
            ;;
        
        # ERC20
        "erc20:approve")
            cmd_erc20_approve "$@"
            ;;
        "erc20:balance")
            cmd_erc20_balance "$@"
            ;;
        
        # æœ¬åœ°æµ‹è¯•
        "imp:start")
            cmd_imp_start "$@"
            ;;
        "imp:stop")
            cmd_imp_stop "$@"
            ;;
        "time:increase")
            cmd_time_increase "$@"
            ;;
        "mine")
            cmd_mine
            ;;
        
        # å¸®åŠ©
        "help"|"--help"|"-h")
            show_help
            ;;
        
        *)
            echo "âŒ Unknown command: $command"
            echo "Use 'rwa help' to see available commands"
            exit 1
            ;;
    esac
}

# æ‰§è¡Œä¸»å‡½æ•°
main "$@"
